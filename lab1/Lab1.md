# Lab1

# 练习1：理解内核启动中的程序入口操作
阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

```
la sp, bootstacktop
```

a指令用于把地址加载到寄存器，将bootstacktop的地址加载到sp寄存器中，为内核设置初始栈指针，为内核设置栈空间，支持后面函数的正常调用。

```
tail kern_init
```

tail指令表示无返回地跳转到另一个函数，跳转到内核初始化函数kern_init开始初始化工作，并不会返回，函数kern_init用于进行初始化内核环境和向用户提供可视化反馈。

# 练习2: 使用GDB验证启动流程

使用 GDB 跟踪 QEMU 模拟的 RISC-V 从加电开始，直到执行内核第一条指令（跳转到 0x80200000）的整个过程：

1.打开终端，进入lab1实验目录，输入tmux并进行左右分屏，左边用于运行QEMU，右边用于GDB调试     

![](D:\1_ZH\2025秋\操作系统\lab1images\屏幕截图 2025-10-08 133156.png)

2.在左边窗口输入make debug启动QEMU，会让虚拟CPU一启动就立刻暂停，并开启调试端口 localhost:1234，通过快捷键进入右边窗口并输入make gdb，GDB连接localhost的1234端口，成功进入了GDB，并停在了RISC-V启动地址 0x1000，也就是加电后的第一条指令位置

![](D:\1_ZH\2025秋\操作系统\lab1images\屏幕截图 2025-10-08 131945(1).png)

3.设置观察点，监视内核是否被加载，在右侧窗口中输入(gdb) watch *0x80200000，一旦地址0x80200000被写入，程序会暂停，验证OpenSBI加载内核的瞬间。SBI最后跳转到0x80200000，将控制权移交内核，输入(gdb) b *0x80200000，在内核入口地址0x80200000设置一个断点。继续运行，等待断点触发，执行(gdb) c，此时GDB会继续执行QEMU中的代码，当OpenSBI固件完成初始化并跳转到内核时，GDB输出

```
Breakpoint 2, kern_entry () at kern/init/entry.S:7
7 la sp, bootstacktop
```

输出内核第一条指令，表明程序控制权已经从OpenSBI成功转交给uCore内核

![](D:\1_ZH\2025秋\操作系统\lab1images\屏幕截图 2025-10-08 132201.png)

4.输入 (gdb) x/10i 0x80200000 ，可以观察反汇编内核入口的指令

![](D:\1_ZH\2025秋\操作系统\lab1images\屏幕截图 2025-10-08 150849.png)

问题一：RISC-V 硬件加电后最初执行的几条指令位于什么地址？

RISC-V 硬件架构在加电复位后，默认从物理地址0x1000处开始执行指令。

输入 (gdb) x/10i 0x1000可以查看地址0x1000处的几条指令：

![](D:\1_ZH\2025秋\操作系统\lab1images\屏幕截图 2025-10-08 151440.png)

问题二：它们主要完成了哪些功能？

这几条指令来自OpenSBI固件，作用是为内核启动做好准备。

```
0x1000：auipc t0, 0x0
```

用于获取当前PC值，并将其写入t0

```
0x1004：addi a1, t0, 32
```

加立即数，把t0加32（也就是偏移0x20）存入a1，让a1指向参数区域的起始地址，即0x1020

```
0x1008：csrr a0, mhartid
```

从mhartid寄存器读取当前CPU核编号，写入 a0，方便后面初始化每个核

```
0x100c：ld t0, 24(t0)
```

从 t0 + 24的地址加载一个64位地址到 t0 中，目的是取出下一步跳转的目标地址

```
0x1010：jr t0
```

跳转到to指向的地址，执行权就此交给OPENSBI主流程

后面是一些未定义指令，用来占位或用于调试和异常处理测试。
